# Chapter1

- `/app`: アプリケーションのすべてのルート、コンポーネント、ロジックが含まれています。主にここから作業します。
- `/app/lib`: 再利用可能なユーティリティ関数やデータ取得関数など、アプリケーションで使用される関数が含まれます。
- `/app/ui`: カード、テーブル、フォームなど、アプリケーションのすべての UI コンポーネントが含まれます。時間を節約するために、これらのコンポーネントは事前にスタイル設定されています。
- `/public`: 画像など、アプリケーションのすべての静的アセットが含まれます。
- `/script`: 後の章でデータベースにデータを設定するために使用するシード スクリプトが含まれています。
- 設定ファイル`next.config.js`: アプリケーションのルートなどに設定ファイルがあることにも気づきます。これらのファイルのほとんどは、`create-next-app` を使用して新しいプロジェクトを開始するときに作成され、事前設定されます。このコースではそれらを変更する必要はありません。

# Chapter2

`global.css`をアプリケーション内の任意のコンポーネントにインポートできますが、通常はそれを最上位コンポーネントに追加することをお勧めします。Next.js では、これはroot layoutです(これについては後で詳しく説明します)。

`/app/layout.tsx`ファイルに移動して`global.css`をインポートすることで、グローバルスタイルをアプリケーションに追加します。

## CSS module を追加する

`app/ui/`にhome.module.css を追加し、そこにcssの設定を追加。
`app/page.tsx`でファイルをインポートして、スタイルを適用する。

**CSSモジュールの利点**
CSSクラスをデフォルトでコンポーネントにローカルにスコープする方法を提供し、モジュール性を向上させ、スタイルの競合のリスクを軽減します。

## clsx ライブラリをクラスネームを切り替えるために追加する

clsx はクラス名を簡単に切り替えることができるライブラリです。
次のように条件付きでクラスを適用できます。

```TypeScript: /app/ui/invoices/status.tsx
import clsx from 'clsx';

export default function InvoiceStatus({ status }: { status: string }) {
  return (
    <span
      className={clsx(
        'inline-flex items-center rounded-full px-2 py-1 text-sm',
        {
          'bg-gray-100 text-gray-500': status === 'pending',
          'bg-green-500 text-white': status === 'paid',
        },
      )}
    >
    // ...
)}
```

# Chapter3

Next.jsは、`next/font`モジュールを使用するしたときアプリケーション内のフォントを自動的で最適化します。ビルド時にフォントファイルをダウンロードし、他の静的アセットとともにホストします。これは、ユーザーがアプリケーションにアクセスしたときに、パフォーマンスに影響を与えるようなフォントに対する追加のネットワーク要求がないことを意味します。

## プライマリフォントの追加

`/app/ui`フォルダー内に`fonts.ts`という名前の新しいファイルを作成します。このファイルを使用して、アプリケーション全体で使用されるフォントを保存します。

`next/font/google`モジュールから`Inter`フォントをインポートします。これがプライマリフォントになります。次に、どのサブセットかを指定しますロードしたいと考えています。この場合、`latin`

## 画像の最適化

Next.jsは、画像などの静的アセットを最上位フォルダー`/public`の下に提供できます。`/public`内部のファイルはアプリケーションで参照できます。

通常の HTML では、次のように画像を追加します。

```HTML
<img
  src="/hero.png"
  alt="Screenshots of the dashboard project showing desktop version"
/>
```

ただし、これは手動で以下を行う必要があることを意味します。

- 画像がさまざまな画面サイズで応答することを確認します。
- さまざまなデバイスの画像サイズを指定します。
- 画像の読み込み時にレイアウトがずれるのを防ぎます。
- ユーザーのビューポートの外にある画像を遅延読み込みします。

これらの最適化を手動で実装する代わりに、`next/image`コンポーネントを使用して画像を自動的に最適化できます。

## コンポーネント<Image>

コンポーネント<Image>は HTML<img>タグの拡張であり、次のような自動画像最適化機能が付属しています。

- 画像読み込み時に自動的にレイアウトがずれるのを防ぎます。
- 小さなビューポートを備えたデバイスに大きな画像が送信されるのを避けるために、画像のサイズを変更します。
- デフォルトで画像を遅延読み込みします (画像はビューポートに入るときに読み込まれます)。
- WebPなどの最新の形式で画像を提供するとAVIFブラウザがサポートしている場合。

# Chapter4

## ネストされたルーティング

Next.js はファイル システム ルーティングを使用し、フォルダーを使用してネストされたルートを作成します。各フォルダーは、URL セグメントにマップされるルートセグメントを表します。
![nested_routing](folders-to-url-segments.avif)

`layout.tsx`および`page.tsx`ファイルを使用して、ルートごとに個別のUIを作成できます。

`page.tsx`はReact ンポーネントをエクスポートする特別な Next.js ファイルであり、ルートにアクセスできるようにするために必要です。アプリケーションには、すでにページファイル`/app/page.tsx`があります。これは、ルートに関連付けられたホームページです。

## ダッシュボードレイアウトの作成

ダッシュボードには、複数のページにわたって共有されるある種のナビゲーションがあります。Next.js では、特別な`layout.tsx`ファイルを使用して、複数のページ間で共有される UI を作成できます。

`<SideNav />`まず、コンポーネントをレイアウトにインポートします。このファイルにインポートするコンポーネントはすべてレイアウトの一部になります。

`<Layout />`コンポーネントはchildren propを受け取ります。このchildrenはページまたは別のレイアウトのいずれかになります。`/dashboard`内部のページは<Layout />に自動的にネストされます。
![nested_layout](shared-layout.avif)

Next.js でレイアウトを使用する利点の 1つは、ナビゲーション時にページ コンポーネントのみが更新され、レイアウトは再レンダリングされないことです。これは部分レンダリングと呼ばれます。
![partial-rendering](partial-rendering-dashboard.avif)

# Chapter5

## なぜナビゲーションを最適化するのでしょうか?

ページ間をリンクするには、従来は<a>HTML 要素を使用していました。現時点では、サイドバーのリンクには<a>要素が使用されていますが、ブラウザーでホーム、請求書、顧客のページ間を移動するとどうなるかに注目してください。

各ページ ナビゲーションでページ全体が更新されます。

## コンポーネント<Link>

Next.js では、<Link />コンポーネントを使用してアプリケーション内のページ間をリンクできます。JavaScriptを使用してクライアント側のナビゲーション<Link>を実行できるようになります。

`<Link />`コンポーネントを使用するには、 `/app/ui/dashboard/nav-links.tsx`を開き、Linkコンポーネントを`next/link`からインポートします。次に、<a>タグを<Link>に置き換えます。

## 自動コード分割とプリフェッチ

ナビゲーション エクスペリエンスを向上させるために、Next.js はアプリケーションをルート セグメントごとに自動的にコード分割します。これは従来の React SPAとは異なります、ブラウザーは初期ロード時にすべてのアプリケーション コードをロードします。

コードをルートごとに分割すると、ページが分離されます。特定のページでエラーが発生しても、アプリケーションの残りの部分は引き続き動作します。

さらに、運用環境では、<Link>ブラウザのビューポートにコンポーネントが表示されるたびに、Next.js がリンクされたルートのコードをバックグラウンドで自動的にプリフェッチします。ユーザーがリンクをクリックするまでに、宛先ページのコードはすでにバックグラウンドで読み込まれており、これによりページがほぼ瞬時に遷移します。

## アクティブなリンクを表示する

`usePathname()`はフックなので、`nav-links.tsx`をクライアントコンポーネントに変える必要があります。React の`"use client"`ディレクティブをファイルの先頭に追加し、`next/navigation`を`usePathname()`からインポートします。

# Chapter7

## サーバーコンポーネントを使用したデータのフェッチ

デフォルトでは、Next.js アプリケーションは**React Server Components**を使用します。サーバーコンポーネントを使用したデータの取得は比較的新しいアプローチであり、サーバーコンポーネントを使用することにはいくつかの利点があります。

- サーバーコンポーネントは Promise をサポートし、データのフェッチなどの非同期タスクに対するよりシンプルなソリューションを提供します。`useEffect``useState`やデータ取得ライブラリ`async/await`に手を伸ばさずに構文を使用できます。
- サーバーコンポーネン トはサーバー上で実行されるため、高価なデータのフェッチとロジックをサーバー上に保持し、結果のみをクライアントに送信できます。
- 前述したように、サーバーコンポーネントはサーバー上で実行されるため、追加のAPIレイヤーを使用せずにデータベースに直接クエリを実行できます。

## SQLの使用

Vercel Postgres SDK はSQLインジェクションに対する保護を提供します。

`/app/lib/data.ts`に移動すると、@vercel/postgresからsql機能 をインポートしていることがわかります。この関数を使用すると、データベースにクエリを実行できます。

```javascript:
import { sql } from '@vercel/postgres';

// ...
```

任意のサーバー コンポーネント内でsqlを呼び出すことができます。ただし、コンポーネントをより簡単にナビゲートできるように、すべてのデータ クエリを`data.ts`ファイル内に保持しており、それらをコンポーネントにインポートできます。

## ダッシュボード概要ページのデータの取得

ただし...注意しなければならないことが 2 つあります。

- データ リクエストは意図せずに相互にブロックし、リクエストウォーターフォールを作成します。
- デフォルトでは、Next.js はパフォーマンスを向上させるためにルートを事前レンダリングします。これは静的レンダリングと呼ばれます。したがって、データが変更されても、ダッシュボードには反映されません。

## リクエスト ウォーターフォールとは何ですか?

「ウォーターフォール」とは、前のリクエストの完了に依存する一連のネットワークリクエストを指します。データフェッチの場合、各リクエストは、前のリクエストがデータを返した後にのみ開始できます。
![](sequential-parallel-data-fetching.avif)

たとえば、実行を開始するfetchRevenue()前に実行を待つ必要があるfetchLatestInvoices()などです。

```javascript:app/dashboard/page.tsx
const revenue = await fetchRevenue();
const latestInvoices = await fetchLatestInvoices(); // wait for fetchRevenue() to finish
const {
  numberOfInvoices,
  numberOfCustomers,
  totalPaidInvoices,
  totalPendingInvoices,
} = await fetchCardData(); // wait for fetchLatestInvoices() to finish
```

## 並列データフェッチ

ウォーターフォールを回避する一般的な方法は、すべてのデータ要求を同時に、つまり並行して開始することです。
JavaScriptでは、すべての Promise を同時に開始するために`Promise.all()`または`Promise.allSettled()`が使えます。たとえば、 `data.ts`では、次の`Promise.all()` `fetchCardData()`関数を使用しています。

````javascript:app/lib/data.ts
export async function fetchCardData() {
  try {
    const invoiceCountPromise = sql`SELECT COUNT(*) FROM invoices`;
    const customerCountPromise = sql`SELECT COUNT(*) FROM customers`;
    const invoiceStatusPromise = sql`SELECT
         SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) AS "paid",
         SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) AS "pending"
         FROM invoices`;

    const data = await Promise.all([
      invoiceCountPromise,
      customerCountPromise,
      invoiceStatusPromise,
    ]);
    // ...
  }
}```
````

このパターンを使用すると、次のことが可能になります。

- すべてのデータフェッチの実行を同時に開始すると、パフォーマンスの向上につながる可能性があります。
- 任意のライブラリまたはフレームワークに適用できるネイティブ JavaScript パターンを使用します。

ただし、この JavaScriptパターンのみに依存することには欠点が1つあります。1つのデータクエストが他のすべてのデータリクエストよりも遅い場合はどうなるでしょうか。

#　Chapter8

## 静的レンダリングとは何ですか?

静的レンダリングでは、データのフェッチとレンダリングがビルド時(デプロイ時)または再検証中にサーバー上で行われます。結果はコンテンツ配信ネットワーク(CDN)に配布およびキャッシュできます。
![](static-site-generation.avif)
ユーザーがアプリケーションにアクセスするたびに、キャッシュされた結果が提供されます。静的レンダリングにはいくつかの利点があります。

- Webサイトの高速化: 事前にレンダリングされたコンテンツをキャッシュし、グローバルに配布できます。これにより、世界中のユーザーがより迅速かつ確実に Web サイトのコンテンツにアクセスできるようになります。
- サーバー負荷の軽減: コンテンツがキャッシュされるため、サーバーはユーザーのリクエストごとにコンテンツを動的に生成する必要がありません。
- SEO: 事前にレンダリングされたコンテンツは、ページの読み込み時にすでに利用可能であるため、検索エンジンのクローラーにとってインデックス付けが容易です。これにより、検索エンジンのランキングが向上する可能性があります。

静的レンダリングは、データのないUI、または静的なブログ投稿や製品ページなど、ユーザー間で共有されるデータのUIに役立ちます。定期的に更新されるパーソナライズされたデータを含むダッシュボードには適さない可能性があります。

## ダイナミックレンダリングとは何ですか?

動的レンダリングでは、リクエスト時(ユーザーがページにアクセスしたとき)に、各ユーザーのコンテンツがサーバー上でレンダリングされます。動的レンダリングにはいくつかの利点があります。

- リアルタイムデータ: 動的レンダリングにより、アプリケーションはリアルタイムまたは頻繁に更新されるデータを表示できます。これは、データが頻繁に変更されるアプリケーションに最適です。
- ユーザー固有のコンテンツ: ダッシュボードやユーザー プロファイルなどのパーソナライズされたコンテンツを提供し、ユーザー インタラクションに基づいてデータを更新することが簡単になります。
- リクエスト時の情報: 動的レンダリングを使用すると、Cookie や URL 検索パラメータなど、リクエスト時にのみ知ることができる情報にアクセスできます。

デフォルトでは、`@vercel/postgres`独自のキャッシュセマンティクスを設定しません。これにより、フレームワークは独自の静的および動的動作を設定できるようになります。

サーバーコンポーネント内で呼び出される Next.js API`unstable_noStore`またはデータ取得関数を使用して、静的レンダリングをオプトアウトできます。これを追加しましょう。

## 遅いデータフェッチのシミュレーション

遅いデータフェッチをシミュレートするために人為的に 3 秒の遅延を追加しています。その結果、データがフェッチされている間、ページ全体がブロックされることになります。

動的レンダリングを使用すると、**アプリケーションは最も遅いデータフェッチと同じ速度でしか動作しません。**

# Chapter9

## ストリーミング

前の章では、ダッシュボード ページを動的にしましたが、データのフェッチが遅いことがアプリケーションのパフォーマンスにどのような影響を与える可能性があるかについて説明しました。データ要求が遅い場合にユーザー エクスペリエンスを向上させる方法を見てみましょう。

## ストリーミングとは何ですか?

ストリーミングは、ルートをより小さな「チャンク」に分割し、準備が整ったらサーバーからクライアントに段階的にストリーミングできるデータ転送技術です。
![](server-rendering-with-streaming.avif)

ストリーミングすることで、遅いデータ要求によってページ全体がブロックされるのを防ぐことができます。これにより、ユーザーは、UI がユーザーに表示される前にすべてのデータが読み込まれるのを待たずに、ページの一部を表示して操作できるようになります。
![](server-rendering-with-streaming-chart.avif)

各コンポーネントはチャンクとみなすことができるため、ストリーミングは React のコンポーネント モデルとうまく連携します。

Next.js でストリーミングを実装する方法は 2 つあります。

- ページレベルで、`loading.tsx`ファイルとともに。
- 特定のコンポーネントの場合は、`<Suspense>`。

## ページ全体をストリーミングするloading.tsx

`/app/dashboard`フォルダー内に、次の名前の新しいファイルを作成します`loading.tsx`。

いくつかのことが起こっています。

1. `loading.tsx`は Suspense 上に構築された特別な Next.js ファイルで、ページコンテンツの読み込み中に代替として表示するフォールバック UI を作成できます。
2. `<Sidebar>`は静的であるため、`<Sidebar>`はすぐに表示されます。ユーザーは、動的コンテンツの読み込み中に対話できます。
3. ユーザーは、ページの読み込みが完了するまで待つ必要はありません (これを中断可能なナビゲーションと呼びます)。

## ロードスケルトンの追加

読み込みスケルトンは、UIの簡略化されたバージョンです。多くの Webサイトは、コンテンツが読み込まれていることをユーザーに示すプレースホルダー (またはフォールバック) としてこれらを使用します。埋め込む UIは`loading.tsx`静的ファイルの一部として埋め込まれ、最初に送信されます。その後、残りの動的コンテンツがサーバーからクライアントにストリーミングされます。

## ルートグループでのスケルトンの読み込みバグを修正

現時点では、読み込み中のスケルトンは請求書と顧客ページにも適用されます。

`loading.tsx`はファイルシステムよりも上位のレベルであるため、`/invoices/page.tsx` `/customers/page.tsx`のページにも適用されます。

これはルートグループで変更できます。ダッシュボードフォルダー内に`/(overview)`という新しいフォルダーを作成します。次に、`loading.tsx`ファイルと`page.tsx`ファイルをフォルダー内に移動します。
![](route-group.avif)

これで、`loading.tsx`ファイルはダッシュボードの概要ページにのみ適用されます。

ルートグループを使用すると、URLパス構造に影響を与えることなく、ファイルを論理グループに編成できます。かっこ`()`を使用して新しいフォルダーを作成すると、その名前はURLパスに含まれません。なので`/dashboard/(overview)/page.tsx` は`/dashboard`のURLに対応します。

ここでは、ルートグループを使用して、loading.tsxをダッシュボードの概要ページにのみ適用されるようにしています。ただし、ルート グループを使用して、アプリケーションをセクション ((marketing)ルートと(shop)ルートなど) に分割したり、大規模なアプリケーションの場合はチームごとに分割したりすることもできます。

(こういうことを言っている。)
![](route-group-organisation.avif)
[Route Groups](https://nextjs.org/docs/app/building-your-application/routing/route-groups)

## コンポーネントのストリーミング

これまでのところ、ページ全体をストリーミングしています。ただし、代わりに、`React Suspense` を使用すると、より詳細に特定のコンポーネントをストリーミングできます。

サスペンスを使用すると、何らかの条件が満たされるまで (データがロードされるなど)、アプリケーションのレンダリング部分を延期できます。動的コンポーネントをサスペンスでラップできます。次に、動的コンポーネントのロード中に表示するフォールバックコンポーネントを渡します。

遅いデータリクエスト`fetchRevenue()`を覚えていると思いますが、これはページ全体の速度を低下させているリクエストです。ページをブロックする代わりに、`Suspense`を使用してこのコンポーネントのみをストリーミングし、ページの残りの UIをすぐに表示できます。

そのためには、データのフェッチをコンポーネントに移動する必要があります。コードを更新して、それがどのようになるかを確認してみましょう。

`fetchRevenue()`のすべてのインスタンスとそのデータを`/dashboard/(overview)/page.tsx`から削除します。

次に、`<Suspense>`をReact からインポートして、`<RevenueChart />` をラップします。フォールバックコンポーネントに`<RevenueChartSkeleton>`を渡すことができます。

→Suspence はchildrenのPromiseの状態を監視していて、読み込み中ならfallbackを、完了したらchildrenを表示する感じっぽい。

## サスペンスの境界線をどこに置くかを決める

サスペンスの境界をどこに置くかは、いくつかの要素によって決まります。

1. ストリーミング中にユーザーにページをどのように体験してもらいたいか。
2. どのコンテンツを優先したいか。
3. コンポーネントがデータの取得に依存している場合。

- `loading.tsx`で行ったようにページ全体をストリーミングすることもできますが、コンポーネントの 1つでデータの取得が遅い場合、読み込み時間が長くなる可能性があります。

- すべてのコンポーネントを個別にストリーミングすることもできますが、準備が整うとUIが画面に表示される可能性があります。

- ページセクションをストリーミングすることによって、千鳥状の効果を作成することもできます。ただし、ラッパーコンポーネントを作成する必要があります。

サスペンス境界をどこに置くかは、アプリケーションによって異なります。一般に、データのフェッチを必要なコンポーネントまで移動し、それらのコンポーネントを Suspense でラップすることをお勧めします。ただし、アプリケーションが必要とする場合は、セクションまたはページ全体をストリーミングしても問題はありません。

# Chapter10

Partial Prerendering (部分的なプリレンダリング)

## 静的コンテンツと動的コンテンツの結合

現在、ルート内で動的関数(たとえば`noStore()`、`cookies()`など)を呼び出すと、ルート全体が動的になります。

これは、今日のほとんどの Web アプリの構築方法と一致しており、アプリケーション全体または特定のルートに対して**静的レンダリング**と**動的レンダリング**のいずれかを選択します。

ただし、ほとんどのルートは完全に静的または動的ではありません。静的コンテンツと動的コンテンツの両方を含むルートがある場合があります。たとえば、ソーシャル メディア フィードがあるとします。投稿は静的ですが、投稿に対する「いいね！」は動的です。または、 eコマースサイトでは、商品の詳細は静的ですが、ユーザーのカートは動的であります。

## 部分プリレンダリングとは何ですか?

Next.js 14 には、**Partial Prerendering**と呼ばれる新しいレンダリングモデルのプレビューがあります。部分的な事前レンダリングは、一部の部分を動的に保ちながら、静的な読み込みシェルでルートをレンダリングできるようにする実験的な機能です。つまり、ルートの動的部分を分離できます。例えば：
![](thinking-in-ppr.avif)
ユーザーがルートを訪問すると:

- 静的ルートシェルが提供されるため、初期ロードが高速になります。
- シェルには、動的コンテンツが非同期で読み込まれる穴が残ります。
- 非同期ホールは並行して読み込まれるため、ページの全体的な読み込み時間が短縮されます。

これは、ルート全体が完全に静的または動的である現在のアプリケーションの動作とは異なります。

部分プリレンダリングは、超高速の静的エッジ配信と完全な動的機能を組み合わせたもので、 Webアプリケーションのデフォルトのレンダリングモデルになる可能性があると考えています。静的サイト生成と動的配信の長所を組み合わせます。

## 部分的なプリレンダリングはどのように機能しますか?

部分的な事前レンダリングは React の同時 API を活用しますサスペンスを使用します何らかの条件が満たされるまで (データがロードされるなど)、アプリケーションのレンダリング部分を延期します。

フォールバックは、他の静的コンテンツとともに初期静的ファイルに埋め込まれます。ビルド時 (または再検証中) に、ルートの静的な部分が事前にレンダリングされ、残りの部分はユーザーがルートを要求するまで延期されます。

コンポーネントを Suspense でラップしても、コンポーネント自体が動的になるのではなく (以前にunstable_noStoreでこの動作を実現していたことを思い出してください)、Suspense はルートの静的部分と動的部分の間の境界として使用されることに注意してください。

部分事前レンダリングの優れた点は、それを使用するためにコードを変更する必要がないことです。Suspense を使用してルートの動的部分をラップしている限り、Next.js はルートのどの部分が静的でどの部分が動的であるかを認識します。

## まとめ

要約すると、アプリケーションでのデータ取得を最適化するために次のことを行いました。

1. サーバーとデータベース間の待ち時間を短縮するために、アプリケーション コードと同じリージョンにデータベースを作成しました。
2. React Server Components を使用してサーバー上のデータを取得しました。これにより、高価なデータのフェッチとロジックをサーバー上に保持し、クライアント側の JavaScript バンドルを削減し、データベースの秘密がクライアントに公開されるのを防ぐことができます。
3. SQL を使用して必要なデータのみを取得することで、リクエストごとに転送されるデータ量と、メモリ内のデータを変換するために必要な JavaScript の量を削減しました。
4. JavaScript を使用してデータの取得を並列化します。そうすることが合理的である場合。
5. 遅いデータ要求によってページ全体がブロックされるのを防ぎ、ユーザーがすべてが読み込まれるのを待たずに UI の操作を開始できるようにするために、ストリーミングを実装しました。
6. データのフェッチを必要なコンポーネントに移動し、部分的な事前レンダリングに備えてルートのどの部分を動的にする必要があるかを分離します。

# Chapter11

検索とページネーションの追加

- `<Search/>`ユーザーは特定の請求書を検索できます。
- `<Pagination/>`ユーザーが請求書のページ間を移動できるようにします。
- `<Table/>`請求書を表示します。

検索機能はクライアントとサーバーにまたがります。ユーザーがクライアント上で請求書を検索すると、URL パラメーターが更新され、サーバー上でデータが取得され、新しいデータを使用してテーブルがサーバー上で再レンダリングされます。

## なぜ URL 検索パラメータを使用するのでしょうか?

上で述べたように、URL 検索パラメータを使用して検索状態を管理します。クライアント側の状態を使用することに慣れている場合、このパターンは新しいかもしれません。

URL パラメータを使用して検索を実装すると、次のような利点があります。

- ブックマーク可能および共有可能な URL: 検索パラメータはURL内にあるため、ユーザーは、将来の参照や共有のために、検索クエリやフィルタを含むアプリケーションの現在の状態をブックマークできます。
- サーバー側レンダリングと初期ロード: URLパラメーターをサーバー上で直接使用して初期状態をレンダリングできるため、サーバーレンダリングの処理が容易になります。
- 分析と追跡: URL に検索クエリとフィルターを直接含めることで、追加のクライアント側ロジックを必要とせずに、ユーザーの行動を追跡することが容易になります。

## 検索機能の追加

これらは、検索機能を実装するために使用する Next.js クライアントフックです。

- `useSearchParams`: 現在のURLのパラメータにアクセスできます。たとえば、`/dashboard/invoices?page=1&query=pending`このURLの検索パラメータは次のようになります`{page: '1', query: 'pending'}`。
- `usePathname`: 現在のURLのパス名を読み取ることができます。たとえば、route`/dashboard/invoices` の場合、`usePathname`は`dashboard/invoices`を返します。
- `useRouter`: クライアント コンポーネント内のルート間のナビゲーションをプログラムで有効にします。使用できる方法は複数あります。
  実装手順の概要を次に示します。

ユーザーの入力をキャプチャします。
検索パラメータを使用して URL を更新します。
URL を入力フィールドと同期させてください。
検索クエリを反映するようにテーブルを更新します。

## 1.ユーザーの入力をキャプチャする

`/app/ui/search.tsx`の`<Search>`コンポーネントに移動すると、次のことがわかります。

- `"use client"`- これはクライアント コンポーネントです。つまり、イベント スナーとフックを使用できます。
- `<input>`- これは検索入力です。

新しい`handleSearch`関数を作成し、`<input>`要素に`onChange`リスナーを追加します。入力値が変化するたびに`onChange`が`handleSearch`を呼び出します。

## 2.検索パラメータを使用してURLを更新します

`'next/navigation'`から`useSearchParams`フックをインポートし、変数に割り当てます。

`handleSearch`の内部で、新しい`searchParams`変数を使用する、`URLSearchParams`を新規作成します。

```javascript:
  function handleSearch(term: string) {
    const params = new URLSearchParams(searchParams);
  }
```

`URLSearchParams`は、URLクエリパラメーターを操作するためのユーティリティメソッドを提供する Web API です。複雑な文字列リテラルを作成する代わりに、それを使用して のような params 文字列を取得できます`?page=1&query=a`。

次に、ユーザーの入力に基づいた params 文字列を`set`します。入力が空の場合は、次のように`delete`します。

```javascript:
if (term) {
  params.set("query", term);
} else {
  params.delete("query");
}
```

これでクエリ文字列が得られました。Next.jsuseRouterとusePathnameフックを使用して URL を更新できます。

`useRouter`と`usePathname`を`next/navigation`からインポートし、`handleSearch`の中で`useRouter()`の`replace`メソッドを使用します。

何が起こっているかの内訳は次のとおりです。

- `${pathname}`あなたの場合、現在のパスです`"/dashboard/invoices"`。
- ユーザーが検索バーに入力すると、入力が`params.toString()`で URLに適した形式に変換されます。
- `replace(${pathname}?${params.toString()})`でURLをユーザーの検索データで更新します。たとえば、ユーザーが「Lee」を検索したとすると、URLは`/dashboard/invoices?query=lee`になります。
- Next.js のクライアント側ナビゲーションのおかげで、URL はページをリロードしなくても更新されます (これについては、ページ間のナビゲーションに関する章で学習しました)。

## URL と入力の同期を維持する

入力フィールドがURLと同期し、共有時にデータが入力されるようにするには、`defaultValue`以下から読み取ることで`searchParams`を`input`に渡すことができます。

## テーブルの更新

最後に、検索クエリを反映するようにテーブル コンポーネントを更新する必要があります。

請求書ページに戻ります。
ページ コンポーネントはという prop を受け入れるsearchParamsため、現在の URL パラメータを<Table>コンポーネントに渡すことができます。

クライアントサイドでparamsを読み込みたい場合は、useSearchParamsフックを使う。

## ベストプラクティス: デバウンス

おめでとう！Next.js で検索を実装しました。しかし、それを最適化するためにできることはあります。

`handleSearch`関数内に`console.log`を追加します。

キーストロークごとに URL を更新するため、キーストロークごとにデータベースにクエリを実行することになります。私たちのアプリケーションは小さいため、これは問題ではありませんが、アプリケーションに数千人のユーザーがいて、各ユーザーがキーストロークごとに新しいリクエストをデータベースに送信すると想像してください。

```JavaScript:
function handleSearch(term: string) {
  console.log(`searching... ${term}`);

  const params = new URLSearchParams(searchParams);

  // ...
}
```

デバウンスは、関数が起動できる速度を制限するプログラミング手法です。この例では、ユーザーが入力をやめたときにのみデータベースにクエリを実行する必要があります。

デバウンスの仕組み:

1. トリガーイベント: デバウンスする必要があるイベント (検索ボックスのキーストロークなど) が発生すると、タイマーが開始します。
2. 待機: タイマーが期限切れになる前に新しいイベントが発生すると、タイマーはリセットされます。
3. 実行: タイマーがカウントダウンの終わりに達すると、デバウンス関数が実行されます。

デバウンスは、独自のデバウンス関数を手動で作成するなど、いくつかの方法で実装できます。物事を簡単にするために、`use-debounce`
というライブラリを使用します。

```
npm i use-debounce
```

```javascript:
// ...
import { useDebouncedCallback } from "use-debounce";

// Inside the Search Component...
const handleSearch = useDebouncedCallback((term) => {
  console.log(`Searching... ${term}`);

  const params = new URLSearchParams(searchParams);
  if (term) {
    params.set("query", term);
  } else {
    params.delete("query");
  }
  replace(`${pathname}?${params.toString()}`);
}, 300);
```

この関数は`handleSearch`の内容をラップし、ユーザーが入力をやめてから特定の時間 (300 ミリ秒) が経過した後にのみコードを実行します。

次に、検索バーに再度入力し、開発ツールでコンソールを開きます。次の内容が表示されるはずです。

## ページネーションの追加

検索機能を導入すると、表には一度に 6件の請求書しか表示されないことがわかります。これは、`data.ts` の`fetchFilteredInvoices()`関数が1ページあたり最大6つの請求書を返すためです。

ページネーションを追加すると、ユーザーはさまざまなページを移動してすべての請求書を表示できるようになります。検索の場合と同じように、URLパラメータを使用してページネーションを実装する方法を見てみましょう。

コンポーネントに移動すると、それがクライアントコンポーネントであることがわかります。クライアント上でデータをフェッチすると、データベースの秘密が漏洩してしまうため、これは望ましくありません (API レイヤーを使用していないことに注意してください)。代わりに、サーバー上のデータをフェッチし、それを prop としてコンポーネントに渡すことができます。

`/dashboard/invoices/page.tsx`で、 `fetchInvoicesPages`という新しい関数をインポートし、 `searchParams`から`query`を引数として渡します。

次に、`totalPagesprop` を`<Pagination/>`コンポーネントに渡します。

`<Pagination/>`コンポーネントに移動し、`usePathname`フックと`useSearchParams`フックをインポートします。これを使用して現在のページを取得し、新しいページを設定します。

# Chapter12

## サーバーアクションとは何ですか?

React Server Actions を使用すると、サーバー上で非同期コードを直接実行できます。データを変更するために APIエンドポイントを作成する必要がなくなります。代わりに、サーバー上で実行され、クライアント コンポーネントまたはサーバー コンポーネントから呼び出すことができる非同期関数を作成します。

Web アプリケーションはさまざまな脅威に対して脆弱になる可能性があるため、セキュリティは最優先事項です。ここでサーバー アクションが登場します。サーバー アクションは、さまざまな種類の攻撃から保護し、データを保護し、承認されたアクセスを保証する、効果的なセキュリティ ソリューションを提供します。サーバー アクションは、POST リクエスト、暗号化されたクロージャ、厳格な入力チェック、エラー メッセージのハッシュ化、ホスト制限などの技術を通じてこれを実現し、すべて連携してアプリの安全性を大幅に強化します。

## サーバーアクションでのフォームの使用

React では、`<form>`要素内の`action`属性を使用してアクションを呼び出すことができます。アクションはキャプチャされたデータを含むネイティブ`FormData`を自動的に受け取ります。

```JavaScript:
// Server Component
export default function Page() {
  // Action
  async function create(formData: FormData) {
    'use server';

    // Logic to mutate data...
  }

  // Invoke the action using the "action" attribute
  return <form action={create}>...</form>;
}
```

サーバー コンポーネント内でサーバー アクションを呼び出すことの利点は、段階的な機能拡張です。クライアントで JavaScript が無効になっている場合でもフォームは機能します。

## 請求書の作成

新しい請求書を作成する手順は次のとおりです。

1. ユーザーの入力を取得するフォームを作成します。
2. サーバー アクションを作成し、フォームから呼び出します。
3. サーバー アクション内で、オブジェクトからデータを抽出しますformData。
4. データベースに挿入するデータを検証して準備します。
5. データを挿入し、エラーがあれば処理します。
6. キャッシュを再検証し、ユーザーを請求書ページにリダイレクトします。
