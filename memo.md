# Chapter1

- `/app`: アプリケーションのすべてのルート、コンポーネント、ロジックが含まれています。主にここから作業します。
- `/app/lib`: 再利用可能なユーティリティ関数やデータ取得関数など、アプリケーションで使用される関数が含まれます。
- `/app/ui`: カード、テーブル、フォームなど、アプリケーションのすべての UI コンポーネントが含まれます。時間を節約するために、これらのコンポーネントは事前にスタイル設定されています。
- `/public`: 画像など、アプリケーションのすべての静的アセットが含まれます。
- `/script`: 後の章でデータベースにデータを設定するために使用するシード スクリプトが含まれています。
- 設定ファイル`next.config.js`: アプリケーションのルートなどに設定ファイルがあることにも気づきます。これらのファイルのほとんどは、`create-next-app` を使用して新しいプロジェクトを開始するときに作成され、事前設定されます。このコースではそれらを変更する必要はありません。

# Chapter2

`global.css`をアプリケーション内の任意のコンポーネントにインポートできますが、通常はそれを最上位コンポーネントに追加することをお勧めします。Next.js では、これはroot layoutです(これについては後で詳しく説明します)。

`/app/layout.tsx`ファイルに移動して`global.css`をインポートすることで、グローバルスタイルをアプリケーションに追加します。

## CSS module を追加する

`app/ui/`にhome.module.css を追加し、そこにcssの設定を追加。
`app/page.tsx`でファイルをインポートして、スタイルを適用する。

**CSSモジュールの利点**
CSSクラスをデフォルトでコンポーネントにローカルにスコープする方法を提供し、モジュール性を向上させ、スタイルの競合のリスクを軽減します。

## clsx ライブラリをクラスネームを切り替えるために追加する

clsx はクラス名を簡単に切り替えることができるライブラリです。
次のように条件付きでクラスを適用できます。

```TypeScript: /app/ui/invoices/status.tsx
import clsx from 'clsx';

export default function InvoiceStatus({ status }: { status: string }) {
  return (
    <span
      className={clsx(
        'inline-flex items-center rounded-full px-2 py-1 text-sm',
        {
          'bg-gray-100 text-gray-500': status === 'pending',
          'bg-green-500 text-white': status === 'paid',
        },
      )}
    >
    // ...
)}
```

# Chapter3

Next.jsは、`next/font`モジュールを使用するしたときアプリケーション内のフォントを自動的で最適化します。ビルド時にフォントファイルをダウンロードし、他の静的アセットとともにホストします。これは、ユーザーがアプリケーションにアクセスしたときに、パフォーマンスに影響を与えるようなフォントに対する追加のネットワーク要求がないことを意味します。

## プライマリフォントの追加

`/app/ui`フォルダー内に`fonts.ts`という名前の新しいファイルを作成します。このファイルを使用して、アプリケーション全体で使用されるフォントを保存します。

`next/font/google`モジュールから`Inter`フォントをインポートします。これがプライマリフォントになります。次に、どのサブセットかを指定しますロードしたいと考えています。この場合、`latin`

## 画像の最適化

Next.jsは、画像などの静的アセットを最上位フォルダー`/public`の下に提供できます。`/public`内部のファイルはアプリケーションで参照できます。

通常の HTML では、次のように画像を追加します。

```HTML
<img
  src="/hero.png"
  alt="Screenshots of the dashboard project showing desktop version"
/>
```

ただし、これは手動で以下を行う必要があることを意味します。

- 画像がさまざまな画面サイズで応答することを確認します。
- さまざまなデバイスの画像サイズを指定します。
- 画像の読み込み時にレイアウトがずれるのを防ぎます。
- ユーザーのビューポートの外にある画像を遅延読み込みします。

これらの最適化を手動で実装する代わりに、`next/image`コンポーネントを使用して画像を自動的に最適化できます。

## コンポーネント<Image>

コンポーネント<Image>は HTML<img>タグの拡張であり、次のような自動画像最適化機能が付属しています。

- 画像読み込み時に自動的にレイアウトがずれるのを防ぎます。
- 小さなビューポートを備えたデバイスに大きな画像が送信されるのを避けるために、画像のサイズを変更します。
- デフォルトで画像を遅延読み込みします (画像はビューポートに入るときに読み込まれます)。
- WebPなどの最新の形式で画像を提供するとAVIFブラウザがサポートしている場合。

# Chapter4

## ネストされたルーティング

Next.js はファイル システム ルーティングを使用し、フォルダーを使用してネストされたルートを作成します。各フォルダーは、URL セグメントにマップされるルートセグメントを表します。
![nested_routing](folders-to-url-segments.avif)

`layout.tsx`および`page.tsx`ファイルを使用して、ルートごとに個別のUIを作成できます。

`page.tsx`はReact ンポーネントをエクスポートする特別な Next.js ファイルであり、ルートにアクセスできるようにするために必要です。アプリケーションには、すでにページファイル`/app/page.tsx`があります。これは、ルートに関連付けられたホームページです。

## ダッシュボードレイアウトの作成

ダッシュボードには、複数のページにわたって共有されるある種のナビゲーションがあります。Next.js では、特別な`layout.tsx`ファイルを使用して、複数のページ間で共有される UI を作成できます。

`<SideNav />`まず、コンポーネントをレイアウトにインポートします。このファイルにインポートするコンポーネントはすべてレイアウトの一部になります。

`<Layout />`コンポーネントはchildren propを受け取ります。このchildrenはページまたは別のレイアウトのいずれかになります。`/dashboard`内部のページは<Layout />に自動的にネストされます。
![nested_layout](shared-layout.avif)

Next.js でレイアウトを使用する利点の 1つは、ナビゲーション時にページ コンポーネントのみが更新され、レイアウトは再レンダリングされないことです。これは部分レンダリングと呼ばれます。
![partial-rendering](partial-rendering-dashboard.avif)

# Chapter5

## なぜナビゲーションを最適化するのでしょうか?

ページ間をリンクするには、従来は<a>HTML 要素を使用していました。現時点では、サイドバーのリンクには<a>要素が使用されていますが、ブラウザーでホーム、請求書、顧客のページ間を移動するとどうなるかに注目してください。

各ページ ナビゲーションでページ全体が更新されます。

## コンポーネント<Link>

Next.js では、<Link />コンポーネントを使用してアプリケーション内のページ間をリンクできます。JavaScriptを使用してクライアント側のナビゲーション<Link>を実行できるようになります。

`<Link />`コンポーネントを使用するには、 `/app/ui/dashboard/nav-links.tsx`を開き、Linkコンポーネントを`next/link`からインポートします。次に、<a>タグを<Link>に置き換えます。

## 自動コード分割とプリフェッチ

ナビゲーション エクスペリエンスを向上させるために、Next.js はアプリケーションをルート セグメントごとに自動的にコード分割します。これは従来の React SPAとは異なります、ブラウザーは初期ロード時にすべてのアプリケーション コードをロードします。

コードをルートごとに分割すると、ページが分離されます。特定のページでエラーが発生しても、アプリケーションの残りの部分は引き続き動作します。

さらに、運用環境では、<Link>ブラウザのビューポートにコンポーネントが表示されるたびに、Next.js がリンクされたルートのコードをバックグラウンドで自動的にプリフェッチします。ユーザーがリンクをクリックするまでに、宛先ページのコードはすでにバックグラウンドで読み込まれており、これによりページがほぼ瞬時に遷移します。

## アクティブなリンクを表示する

`usePathname()`はフックなので、`nav-links.tsx`をクライアントコンポーネントに変える必要があります。React の`"use client"`ディレクティブをファイルの先頭に追加し、`next/navigation`を`usePathname()`からインポートします。

# Chapter7

## サーバーコンポーネントを使用したデータのフェッチ

デフォルトでは、Next.js アプリケーションは**React Server Components**を使用します。サーバーコンポーネントを使用したデータの取得は比較的新しいアプローチであり、サーバーコンポーネントを使用することにはいくつかの利点があります。

- サーバーコンポーネントは Promise をサポートし、データのフェッチなどの非同期タスクに対するよりシンプルなソリューションを提供します。`useEffect``useState`やデータ取得ライブラリ`async/await`に手を伸ばさずに構文を使用できます。
- サーバーコンポーネン トはサーバー上で実行されるため、高価なデータのフェッチとロジックをサーバー上に保持し、結果のみをクライアントに送信できます。
- 前述したように、サーバーコンポーネントはサーバー上で実行されるため、追加のAPIレイヤーを使用せずにデータベースに直接クエリを実行できます。

## SQLの使用

Vercel Postgres SDK はSQLインジェクションに対する保護を提供します。

`/app/lib/data.ts`に移動すると、@vercel/postgresからsql機能 をインポートしていることがわかります。この関数を使用すると、データベースにクエリを実行できます。

```javascript:
import { sql } from '@vercel/postgres';

// ...
```

任意のサーバー コンポーネント内でsqlを呼び出すことができます。ただし、コンポーネントをより簡単にナビゲートできるように、すべてのデータ クエリを`data.ts`ファイル内に保持しており、それらをコンポーネントにインポートできます。

## ダッシュボード概要ページのデータの取得

ただし...注意しなければならないことが 2 つあります。

- データ リクエストは意図せずに相互にブロックし、リクエストウォーターフォールを作成します。
- デフォルトでは、Next.js はパフォーマンスを向上させるためにルートを事前レンダリングします。これは静的レンダリングと呼ばれます。したがって、データが変更されても、ダッシュボードには反映されません。

## リクエスト ウォーターフォールとは何ですか?

「ウォーターフォール」とは、前のリクエストの完了に依存する一連のネットワークリクエストを指します。データフェッチの場合、各リクエストは、前のリクエストがデータを返した後にのみ開始できます。
![](sequential-parallel-data-fetching.avif)

たとえば、実行を開始するfetchRevenue()前に実行を待つ必要があるfetchLatestInvoices()などです。

```javascript:app/dashboard/page.tsx
const revenue = await fetchRevenue();
const latestInvoices = await fetchLatestInvoices(); // wait for fetchRevenue() to finish
const {
  numberOfInvoices,
  numberOfCustomers,
  totalPaidInvoices,
  totalPendingInvoices,
} = await fetchCardData(); // wait for fetchLatestInvoices() to finish
```

## 並列データフェッチ

ウォーターフォールを回避する一般的な方法は、すべてのデータ要求を同時に、つまり並行して開始することです。
JavaScriptでは、すべての Promise を同時に開始するために`Promise.all()`または`Promise.allSettled()`が使えます。たとえば、 `data.ts`では、次の`Promise.all()` `fetchCardData()`関数を使用しています。

````javascript:app/lib/data.ts
export async function fetchCardData() {
  try {
    const invoiceCountPromise = sql`SELECT COUNT(*) FROM invoices`;
    const customerCountPromise = sql`SELECT COUNT(*) FROM customers`;
    const invoiceStatusPromise = sql`SELECT
         SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) AS "paid",
         SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) AS "pending"
         FROM invoices`;

    const data = await Promise.all([
      invoiceCountPromise,
      customerCountPromise,
      invoiceStatusPromise,
    ]);
    // ...
  }
}```
````

このパターンを使用すると、次のことが可能になります。

- すべてのデータフェッチの実行を同時に開始すると、パフォーマンスの向上につながる可能性があります。
- 任意のライブラリまたはフレームワークに適用できるネイティブ JavaScript パターンを使用します。

ただし、この JavaScriptパターンのみに依存することには欠点が1つあります。1つのデータクエストが他のすべてのデータリクエストよりも遅い場合はどうなるでしょうか。

#　Chapter8

## 静的レンダリングとは何ですか?

静的レンダリングでは、データのフェッチとレンダリングがビルド時(デプロイ時)または再検証中にサーバー上で行われます。結果はコンテンツ配信ネットワーク(CDN)に配布およびキャッシュできます。
![](static-site-generation.avif)
ユーザーがアプリケーションにアクセスするたびに、キャッシュされた結果が提供されます。静的レンダリングにはいくつかの利点があります。

- Webサイトの高速化: 事前にレンダリングされたコンテンツをキャッシュし、グローバルに配布できます。これにより、世界中のユーザーがより迅速かつ確実に Web サイトのコンテンツにアクセスできるようになります。
- サーバー負荷の軽減: コンテンツがキャッシュされるため、サーバーはユーザーのリクエストごとにコンテンツを動的に生成する必要がありません。
- SEO: 事前にレンダリングされたコンテンツは、ページの読み込み時にすでに利用可能であるため、検索エンジンのクローラーにとってインデックス付けが容易です。これにより、検索エンジンのランキングが向上する可能性があります。

静的レンダリングは、データのないUI、または静的なブログ投稿や製品ページなど、ユーザー間で共有されるデータのUIに役立ちます。定期的に更新されるパーソナライズされたデータを含むダッシュボードには適さない可能性があります。

## ダイナミックレンダリングとは何ですか?

動的レンダリングでは、リクエスト時(ユーザーがページにアクセスしたとき)に、各ユーザーのコンテンツがサーバー上でレンダリングされます。動的レンダリングにはいくつかの利点があります。

- リアルタイムデータ: 動的レンダリングにより、アプリケーションはリアルタイムまたは頻繁に更新されるデータを表示できます。これは、データが頻繁に変更されるアプリケーションに最適です。
- ユーザー固有のコンテンツ: ダッシュボードやユーザー プロファイルなどのパーソナライズされたコンテンツを提供し、ユーザー インタラクションに基づいてデータを更新することが簡単になります。
- リクエスト時の情報: 動的レンダリングを使用すると、Cookie や URL 検索パラメータなど、リクエスト時にのみ知ることができる情報にアクセスできます。

デフォルトでは、`@vercel/postgres`独自のキャッシュセマンティクスを設定しません。これにより、フレームワークは独自の静的および動的動作を設定できるようになります。

サーバーコンポーネント内で呼び出される Next.js API`unstable_noStore`またはデータ取得関数を使用して、静的レンダリングをオプトアウトできます。これを追加しましょう。

## 遅いデータフェッチのシミュレーション

遅いデータフェッチをシミュレートするために人為的に 3 秒の遅延を追加しています。その結果、データがフェッチされている間、ページ全体がブロックされることになります。

動的レンダリングを使用すると、**アプリケーションは最も遅いデータフェッチと同じ速度でしか動作しません。**

# Chapter9

## ストリーミング

前の章では、ダッシュボード ページを動的にしましたが、データのフェッチが遅いことがアプリケーションのパフォーマンスにどのような影響を与える可能性があるかについて説明しました。データ要求が遅い場合にユーザー エクスペリエンスを向上させる方法を見てみましょう。

## ストリーミングとは何ですか?

ストリーミングは、ルートをより小さな「チャンク」に分割し、準備が整ったらサーバーからクライアントに段階的にストリーミングできるデータ転送技術です。
![](server-rendering-with-streaming.avif)

ストリーミングすることで、遅いデータ要求によってページ全体がブロックされるのを防ぐことができます。これにより、ユーザーは、UI がユーザーに表示される前にすべてのデータが読み込まれるのを待たずに、ページの一部を表示して操作できるようになります。
![](server-rendering-with-streaming-chart.avif)

各コンポーネントはチャンクとみなすことができるため、ストリーミングは React のコンポーネント モデルとうまく連携します。

Next.js でストリーミングを実装する方法は 2 つあります。

- ページレベルで、`loading.tsx`ファイルとともに。
- 特定のコンポーネントの場合は、`<Suspense>`。

## ページ全体をストリーミングするloading.tsx

`/app/dashboard`フォルダー内に、次の名前の新しいファイルを作成します`loading.tsx`。

いくつかのことが起こっています。

1. `loading.tsx`は Suspense 上に構築された特別な Next.js ファイルで、ページコンテンツの読み込み中に代替として表示するフォールバック UI を作成できます。
2. `<Sidebar>`は静的であるため、`<Sidebar>`はすぐに表示されます。ユーザーは、動的コンテンツの読み込み中に対話できます。
3. ユーザーは、ページの読み込みが完了するまで待つ必要はありません (これを中断可能なナビゲーションと呼びます)。

## ロードスケルトンの追加

読み込みスケルトンは、UIの簡略化されたバージョンです。多くの Webサイトは、コンテンツが読み込まれていることをユーザーに示すプレースホルダー (またはフォールバック) としてこれらを使用します。埋め込む UIは`loading.tsx`静的ファイルの一部として埋め込まれ、最初に送信されます。その後、残りの動的コンテンツがサーバーからクライアントにストリーミングされます。

## ルートグループでのスケルトンの読み込みバグを修正

現時点では、読み込み中のスケルトンは請求書と顧客ページにも適用されます。

`loading.tsx`はファイルシステムよりも上位のレベルであるため、`/invoices/page.tsx` `/customers/page.tsx`のページにも適用されます。

これはルートグループで変更できます。ダッシュボードフォルダー内に`/(overview)`という新しいフォルダーを作成します。次に、`loading.tsx`ファイルと`page.tsx`ファイルをフォルダー内に移動します。
![](route-group.avif)

これで、`loading.tsx`ファイルはダッシュボードの概要ページにのみ適用されます。

ルートグループを使用すると、URLパス構造に影響を与えることなく、ファイルを論理グループに編成できます。かっこ`()`を使用して新しいフォルダーを作成すると、その名前はURLパスに含まれません。なので`/dashboard/(overview)/page.tsx` は`/dashboard`のURLに対応します。

ここでは、ルートグループを使用して、loading.tsxをダッシュボードの概要ページにのみ適用されるようにしています。ただし、ルート グループを使用して、アプリケーションをセクション ((marketing)ルートと(shop)ルートなど) に分割したり、大規模なアプリケーションの場合はチームごとに分割したりすることもできます。

(こういうことを言っている。)
![](route-group-organisation.avif)
[Route Groups](https://nextjs.org/docs/app/building-your-application/routing/route-groups)

## コンポーネントのストリーミング

これまでのところ、ページ全体をストリーミングしています。ただし、代わりに、`React Suspense` を使用すると、より詳細に特定のコンポーネントをストリーミングできます。

サスペンスを使用すると、何らかの条件が満たされるまで (データがロードされるなど)、アプリケーションのレンダリング部分を延期できます。動的コンポーネントをサスペンスでラップできます。次に、動的コンポーネントのロード中に表示するフォールバックコンポーネントを渡します。

遅いデータリクエスト`fetchRevenue()`を覚えていると思いますが、これはページ全体の速度を低下させているリクエストです。ページをブロックする代わりに、`Suspense`を使用してこのコンポーネントのみをストリーミングし、ページの残りの UIをすぐに表示できます。

そのためには、データのフェッチをコンポーネントに移動する必要があります。コードを更新して、それがどのようになるかを確認してみましょう。

`fetchRevenue()`のすべてのインスタンスとそのデータを`/dashboard/(overview)/page.tsx`から削除します。

次に、`<Suspense>`をReact からインポートして、`<RevenueChart />` をラップします。フォールバックコンポーネントに`<RevenueChartSkeleton>`を渡すことができます。

→Suspence はchildrenのPromiseの状態を監視していて、読み込み中ならfallbackを、完了したらchildrenを表示する感じっぽい。
